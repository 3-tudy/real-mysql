

# 클러스터링 인덱스

InnoDB 스토리지 엔진에서만 지원한다. 클러스터링 인덱스는 테이블의 레코드를 비슷한 것들끼리
묶어서 저장하는 형태로 구현되는데, 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 방식이다.

클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리
묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.

프라이머리 키 값이 변경되는 것은 레코드의 물리적인 저장 위치가 바뀌는 것을 의미하므로 프라이머리 키 값 자체에 대한
의존도가 상당히 크다. 따라서 프라이머리 키를 신중하게 결정해야 한다.

이러한 점 때문에 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수 있다.
그래서 `"클러스터링 인덱스"`와 `"클러스터링 테이블"`은 동의어로 사용되기도 한다.
또한 클러스터링의 기준이 되는 프라이머리 키를 클러스터링 키라고도 표현한다.

일반적으로 B-Tree 인덱스도 인덱스 키 값으로 이미 정렬되어 저장되므로 어떻게 보면 인덱스의 키 값으로
클러스터링 된 것이라고 볼 수 있다. 하지만 이러한 일반적인 B-Tree 인덱스를 클러스터링 인덱스라고 부르지 않는다.
테이블의 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우만 "클러스터링 인덱스" 또는 "클러스터링 테이블"이라고 한다.

---

## 프라이머리 키가 없을 때

프라이머리 키가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 구성될까?
프라이머리 키가 없는 경우에는 InnoDB 스토리지 엔진이 다음 우선순위대로 프라이머리 키를 대체할 칼럼을 선택한다.

1. 프라이머리 키가 있으면 클러스터링 키로 선택됨
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

적절한 클러스터링 후보를 찾지 못하는 경우 내부적으로 레코드의 일련번호 칼럼을 생성하는데, 이는 사용자가
명시적으로 이용하지 못하고 우리에게 아무런 혜택을 가져다 주지 않는다.

---

## 세컨더리 인덱스에 미치는 영향

MyISAM이나 MEMORY 테이블 같은 논-클러스터링 테이블은 INSERT될 때 처음 저장된 공간에서 절대 이동하지 않는다.
ROW-ID를 사용해서 실제 데이터를 찾아오기 때문이다. 
그래서 프라이머리 인덱스와 세컨더리 인덱스의 구조적인 차이가 없다.

InnoDB의 경우 세컨더리 인덱스가 프라이머리 키 값을 저장하고 있기 때문에 레코드가 저장된 주소를 알지 못한다.
이는 클러스터링 키 값이 변경되었을 경우 데이터 레코드의 물리적 위치까지 변경되는 단점이
세컨더리 인덱스까지 영향을 주지 않도록 하기 위함이다.

그래서 InnoDB의 경우 세컨더리 인덱스가 클러스터링 인덱스를 거쳐야만 실제 데이터 레코드에 접근할 수 있다.

---

## 장단점

장점
- 프라이머리 키로 검색할 때 처리 성능이 매우 빠름(특히, 범위 검색)
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

단점
- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적인 인덱스의 크기가 커짐
- 세컨더리 인덱스가 프라이머리 키를 거쳐야 함
- INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 프라이머리 키를 업데이트할 때 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

가장 큰 장단점은 빠른 읽기, 느린 쓰기이다. 웹 온라인 트랜잭션 환경(OLTP, On-Line Transaction Processing)
에서는 쓰기와 읽기의 비율이 2:8 또는 1:9 정도이기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것이
매우 중요하다.

---

## 주의사항

InnoDB 테이블(클러스터링 테이블)에서는 주의할 사항이 있다.

### 클러스터링 인덱스 키의 크기

클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함한다. 그래서 프라이머리 키의 크기에
많은 영향을 받는다. 

5개의 세컨더리 인덱스를 가지는 테이블의 프라이머리 키가 10바이트인 경우와 50바이트인 경우를 비교해 보자.

| 프라이머리 키 크기 | 레코드당 증가하는 인덱스 크기   | 100만 건 레코드 저장 시 증가하는 인덱스 크기 |
|------------|--------------------|-----------------------------|
| 10바이트      | 10바이트 * 5 = 50바이트  | 50바이트 * 1,000,000 = 47MB    |
| 50바이트      | 50바이트 * 5 = 250바이트 | 250바이트 * 1,000,000 = 238MB  |

만약 1,000만 건이 되면 1.9GB가 증가한다. 또한 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의
메모리가 더 필요해진다.

### 무지성 AUTO-INCREMENT 보다는...

앞서 살펴본 내용을 토대로 InnoDB에서의 클러스터링 키는 매우 큰 의미가 있음을 알 수 있다.
따라서 AUTO-INCREMET를 사용해서 클러스터링 키를 생성하기 보다는 업무적으로 해당 레코드를 대표하는 칼럼을
프라이머리 키로 설정하는 것이 좋다. 이는 InnoDB에서 엄청난 차이를 만들어 낼 수 있다.

### 프라이머리 키는 반드시 명시하자

프라이머리 키가 없는 테이블은 없도록 하자. ROW 기반의 복제나 InnoDB 클러스터에서는 모든 테이블이
프라이머리 키를 가져야만 하는 정상적인 복제 성능을 보장하기도 하므로 프라이머리 키는 꼭 생성하는 것이 좋다.

### AUTO-INCREMENT가 나쁜 건 아니야...

만약 세컨더리 인덱스도 사용하고 INSERT가 빈번한 테이블이라면 AUTO_INCREMENT를 이용한
인조 식별자(Surrogate key)를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.

---

## 참고

MyISAM이나 기타 InnoDB를 제외한 테이블의 데이터 레코드는 프라이머리 키나 인덱스 키 값이 변경된다고 해서
실제 데이터 레코드의 위치가 변경되지는 않는다. 데이터 레코드가 INSERT될 때 데이터 파일의 끝에 저장된다.

레코드의 저장된 주소는 MySQL 내부적으로 레코드를 식별하는 아이디로 인식된다. 이를 ROW-ID라고 표현하며,
일부 DBMS에서는 이 값을 이용할 수 있으나, MySQL에서는 사용자에게 노출되지 않는다.

