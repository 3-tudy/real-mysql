

# 유니크 인덱스

유니크 인덱스는 사실 인덱스라기보다는 제약 조건에 가깝다고 볼 수 있다. MySQL에서는 인덱스 없이 유니크 제약만
설정할 방법이 없다.

유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정 값이 아니므로 2개 이상 저장될 수 있다.
MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여된다.

---

## 일반 세컨더리 인덱스와 비교

사실 구조적으로 아무런 차이가 없다!! 성능 관점에서 비교해보자.

### 인덱스 읽기

많은 사람들이 유니크 인덱스가 빠르다고 생각한다. 하지만 그렇지 않다. 

유니크 인덱스는 1건만 읽으면 되지만 유니크하지 않은 세컨더리 인덱스에서는 레코드를 한 건 더 읽어야하므로 느리다 ??
- 유니크하지 않은 세컨더리 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼값을 비교하는 작업이기 때문에 이는 성능상 영향이 거의 없다.
- 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되므로 읽어야 할 레코드가 많아서 느린 것이다.
  - 레코드 1건을 읽는 데 0.1초가 걸렸고 2건을 읽는 데 0.2초가 걸렸다면 후자가 느리다고 할 수는 없다.
  - 완전히 성능적인 측면에서는 이렇게 볼 수 있지만 사용자의 관점에서는 느린 것이라고 볼 수 있을 것 같다.

### 인덱스 쓰기

유니크 인덱스는 쓰기 작업 시 중복되는 값이 있는지 없는지 체크해야 한다. 그래서 유니크하지 않은 세컨더리 인덱스의
쓰기보다 느리다.

그런데 MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을
사용하는데 이 과정에서 데드락이 아주 빈번이 발생한다. 또한 InnoDB 스토리지 엔진에는 인덱스 키의 저장을
버퍼링하기 위해 체인지 버퍼(Change Buffer)가 사용된다. 그래서 인덱스의 저장이나 변경 작업이 상당히
빨리 처리되지만, 안타깝게도 유니크 인덱스는 반드시 중복 체크를 해야 하므로 버퍼링이 불가능하다.

---

## 주의사항

성능이 좋아질거라 기대하고 유니크 인덱스를 생성하지는 않는 것이 좋다.

- 동일한 칼럼에 유니크 인덱스와 일반 인덱스를 각각 생성하기
  - 두 인덱스는 동일한 역할을 하므로 무의미하다.
- 동일한 칼럼에 대해 프라이머리 키와 유니크 인덱스를 각각 생성하기
  - 이 또한 무의미하다.

꼭 유일성이 보장돼야 하는 칼럼에 대해서만 유니크 인덱스를 생성하자.